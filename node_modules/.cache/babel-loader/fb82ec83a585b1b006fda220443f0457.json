{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tf = require(\"@tensorflow/tfjs\");\n/**\n * Receives an image and normalizes it between -1 and 1.\n * Returns a batched image (1 - element batch) of shape [1, w, h, c]\n * @param rasterElement the element with pixels to convert to a Tensor\n */\n\n\nfunction capture(rasterElement) {\n  return tf.tidy(function () {\n    var pixels = tf.browser.fromPixels(rasterElement); // crop the image so we're using the center square\n\n    var cropped = cropTensor(pixels); // Expand the outer most dimension so we have a batch size of 1\n\n    var batchedImage = cropped.expandDims(0); // Normalize the image between -1 and a1. The image comes in between 0-255\n    // so we divide by 127 and subtract 1.\n\n    return batchedImage.toFloat().div(tf.scalar(127)).sub(tf.scalar(1));\n  });\n}\n\nexports.capture = capture;\n\nfunction cropTensor(img) {\n  var size = Math.min(img.shape[0], img.shape[1]);\n  var centerHeight = img.shape[0] / 2;\n  var beginHeight = centerHeight - size / 2;\n  var centerWidth = img.shape[1] / 2;\n  var beginWidth = centerWidth - size / 2;\n  return img.slice([beginHeight, beginWidth, 0], [size, size, 3]);\n}\n\nexports.cropTensor = cropTensor;","map":{"version":3,"sources":["../../src/utils/tf.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;AAeG;;;;;;AAEH,IAAA,EAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAEA;;;;AAIG;;;AACH,SAAgB,OAAhB,CAAwB,aAAxB,EAA8F;AAC1F,SAAO,EAAE,CAAC,IAAH,CAAQ,YAAA;AACX,QAAM,MAAM,GAAG,EAAE,CAAC,OAAH,CAAW,UAAX,CAAsB,aAAtB,CAAf,CADW,CAGX;;AACA,QAAM,OAAO,GAAG,UAAU,CAAC,MAAD,CAA1B,CAJW,CAMX;;AACA,QAAM,YAAY,GAAG,OAAO,CAAC,UAAR,CAAmB,CAAnB,CAArB,CAPW,CASX;AACA;;AACA,WAAO,YAAY,CAAC,OAAb,GAAuB,GAAvB,CAA2B,EAAE,CAAC,MAAH,CAAU,GAAV,CAA3B,EAA2C,GAA3C,CAA+C,EAAE,CAAC,MAAH,CAAU,CAAV,CAA/C,CAAP;AACH,GAZM,CAAP;AAaH;;AAdD,OAAA,CAAA,OAAA,GAAA,OAAA;;AAiBA,SAAgB,UAAhB,CAA4B,GAA5B,EAA4C;AACxC,MAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAT,EAAuB,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAvB,CAAb;AACA,MAAM,YAAY,GAAG,GAAG,CAAC,KAAJ,CAAU,CAAV,IAAe,CAApC;AACA,MAAM,WAAW,GAAG,YAAY,GAAI,IAAI,GAAG,CAA3C;AACA,MAAM,WAAW,GAAG,GAAG,CAAC,KAAJ,CAAU,CAAV,IAAe,CAAnC;AACA,MAAM,UAAU,GAAG,WAAW,GAAI,IAAI,GAAG,CAAzC;AACA,SAAO,GAAG,CAAC,KAAJ,CAAU,CAAC,WAAD,EAAc,UAAd,EAA0B,CAA1B,CAAV,EAAwC,CAAC,IAAD,EAAO,IAAP,EAAa,CAAb,CAAxC,CAAP;AACH;;AAPD,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs\");\n/**\n * Receives an image and normalizes it between -1 and 1.\n * Returns a batched image (1 - element batch) of shape [1, w, h, c]\n * @param rasterElement the element with pixels to convert to a Tensor\n */\nfunction capture(rasterElement) {\n    return tf.tidy(function () {\n        var pixels = tf.browser.fromPixels(rasterElement);\n        // crop the image so we're using the center square\n        var cropped = cropTensor(pixels);\n        // Expand the outer most dimension so we have a batch size of 1\n        var batchedImage = cropped.expandDims(0);\n        // Normalize the image between -1 and a1. The image comes in between 0-255\n        // so we divide by 127 and subtract 1.\n        return batchedImage.toFloat().div(tf.scalar(127)).sub(tf.scalar(1));\n    });\n}\nexports.capture = capture;\nfunction cropTensor(img) {\n    var size = Math.min(img.shape[0], img.shape[1]);\n    var centerHeight = img.shape[0] / 2;\n    var beginHeight = centerHeight - (size / 2);\n    var centerWidth = img.shape[1] / 2;\n    var beginWidth = centerWidth - (size / 2);\n    return img.slice([beginHeight, beginWidth, 0], [size, size, 3]);\n}\nexports.cropTensor = cropTensor;\n//# sourceMappingURL=tf.js.map"]},"metadata":{},"sourceType":"script"}